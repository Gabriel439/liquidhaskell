module Monadic where

import Language.Haskell.Liquid.Prelude ((==>))




class MyMonad m where
  unit :: Arrow a (m a)
  bind :: Arrow (m a) (Arrow (Arrow a (m b)) (m b))


instance MyMonad L where
  unit = lunit
  bind = lbind



lunit = A $ \x -> C x N  -- axiom: runFun unit x == C x N

lbind = A $ \xs -> A $ \f ->
    case xs of
      N        -> N       -- axiom: runFun (runFun bind N) f == N
      (C x xs) ->         -- axiom: runFun (runFun bind (C x xs)) f
                          --        == runFun f x `append` runFun (runFun bind xs) f
        runFun f x `append` runFun (runFun lbind xs) f

--   bind N f        = N
--   bind (C x xs) f = f x `append` bind xs f

data Arrow a b = A {runFun ::  a -> b}

{-@ data Arrow a b <p :: a -> b -> Prop> = A {runFun ::  x:a -> b<p x>} @-}


-- | Express Left Identity

{-@ measure runFun :: (Arrow a b) -> a -> b @-}



-- use abstract refinements to do this:
-- unit and bind should have the appropriate properties to prove left Identity.
prop_left_identity_List :: a -> Arrow a (L b) -> Proof
prop_left_identity_List = prop_left_identity lunit lbind




{-@ type ProofLeftIdentity Unit Bind F X = {v:Proof | runFun (runFun Bind (runFun Unit X)) F  == runFun F X } @-}

{-@ prop_left_identity :: forall <p :: a -> m a -> Prop,
                                  q :: m a -> Arrow (Arrow a (m b)) (m b) -> Prop>.
                          {unit::Arrow<p> a (m a),bind :: Arrow<q> (m a) (Arrow (Arrow a (m b)) (m b)), x :: a, f :: Arrow a (m b)  |- Proof  <: ProofLeftIdentity unit bind f x}
                        unit: Arrow<p> a (m a) -> bind: Arrow<q> (m a) (Arrow (Arrow a (m b)) (m b))
                      -> x:a -> f:Arrow a (m b)
                      -> ProofLeftIdentity unit bind f x
  @-}

prop_left_identity :: (Arrow a (m a)) -> (Arrow (m a) (Arrow (Arrow a (m b)) (m b)))
                    -> a -> (Arrow a (m b))
                    -> Proof
prop_left_identity iunit ibind x f = Proof

-- | Express Left Identity in Haskell

prop_left_identity_HS :: (Eq (m a), Eq (m b)) => (Arrow a (m a)) -> (Arrow (m a) (Arrow (Arrow a (m b)) (m b)))
                      -> a -> (Arrow a (m b))
                      -> Bool
prop_left_identity_HS unit bind x f
  = runFun (runFun bind (runFun unit x)) f == runFun f x



-- | Proof library:

data Proof = Proof


{-@ toProof :: l:a -> r:{a|l = r} -> {v:Proof | l = r } @-}
toProof :: a -> a -> Proof
toProof x y = Proof


{-@ (===) :: l:a -> r:a -> {v:Proof | l = r} -> {v:a | v = l } @-}
(===) :: a -> a -> Proof -> a
(===) x y _ = y

-- | Proof: map
{-@ type Equal X Y = {v:Proof | X == Y} @-}

{- invariant {v:Proof | v == Proof } @-}

{-@ bound chain @-}
chain :: (Proof -> Bool) -> (Proof -> Bool) -> (Proof -> Bool) -> Proof -> Bool
chain p q r v = p v ==> q v ==> r v

{-@  assume by :: forall <p :: Proof -> Prop, q :: Proof -> Prop, r :: Proof -> Prop>.
                 (Chain p q r) => Proof<p> -> Proof<q> -> Proof<r>
@-}
by :: Proof -> Proof -> Proof
by p r = r

{-@ refl :: x:a -> Equal x x @-}
refl :: a -> Proof
refl x = Proof

-- | End library


-- | Append

data L a = N |  C a (L a) deriving (Eq)

{-@ N :: {v:L a | llen v == 0 && v == N } @-}
{-@ C :: x:a -> xs:L a -> {v:L a | llen v == llen xs + 1 && v == C x xs } @-}

{-@ data L [llen] @-}
{-@ invariant {v: L a | llen v >= 0} @-}

{-@ measure llen :: L a -> Int @-}
llen :: L a -> Int
llen N = 0
llen (C x xs) = 1 + llen xs


append :: L a -> L a -> L a
append N xs        = xs
append (C y ys) xs = C y (append ys xs)


-- | All the followin will be autocatically generated by the definition of append
-- |  and a liquid annotation
-- |
-- |  axiomatize append
-- |

{-@ measure append :: L a -> L a -> L a @-}
{-@ assume append :: xs:L a -> ys:L a -> {v:L a | v == append xs ys } @-}

{-@ assume axiom_append_nil :: xs:L a -> {v:Proof | append N xs == xs} @-}
axiom_append_nil :: L a -> Proof
axiom_append_nil xs = Proof

{-@ assume axiom_append_cons :: x:a -> xs: L a -> ys: L a
          -> {v:Proof | append (C x xs) ys == C x (append xs ys) } @-}
axiom_append_cons :: a -> L a -> L a -> Proof
axiom_append_cons x xs ys = Proof

-- | End  append
