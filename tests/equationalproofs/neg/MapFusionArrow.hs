-- |   A first example in equalional reasoning.
-- |  From the definition of append we should be able to
-- |  semi-automatically prove the two axioms.

-- | Note for soundness we need
-- | totallity: all the cases should be covered
-- | termination: we cannot have diverging things into proofs

{-@ LIQUID "totality" @-}

module Append where

import Language.Haskell.Liquid.Prelude

import Prelude hiding (map, (.))
data L a = N |  C a (L a) deriving (Eq)

{-@ N :: {v:L a | llen v == 0 && v == N } @-}
{-@ C :: x:a -> xs:L a -> {v:L a | llen v == llen xs + 1 && v == C x xs } @-}

{-@ data L [llen] @-}
{-@ invariant {v: L a | llen v >= 0} @-}

{-@ measure llen :: L a -> Int @-}
llen :: L a -> Int
llen N = 0
llen (C x xs) = 1 + llen xs


-- logic does not like functions:
-- wrap functions in a data constructor

data Arrow a b = A {runFun :: a -> b}
{-@ measure runFun :: Arrow a b -> a -> b @-}
{-@ assume runFun :: f:Arrow a b -> x:a -> {v:b | v = runFun f x } @-}
-- axiomatize map
map :: (Arrow a b) -> L a -> L b
map _ N = N
map f (C x xs) = runFun f x `C` map f xs



{-@ assume axiom_compose :: f:(Arrow b c) -> g:(Arrow a b) -> x:a -> {v:Proof | runFun f (runFun g x) == runFun (compose f g) x} @-}
axiom_compose :: (Arrow b c) -> (Arrow a b) -> a -> Proof
axiom_compose f g x = Proof

{-@ assume compose :: f:(Arrow b c) -> g:(Arrow a b) -> {v:Arrow a c | v = compose f g} @-}
compose :: (Arrow b c) -> (Arrow a b) -> (Arrow a c)
compose f g = A $ \x -> runFun f (runFun g x)

{-@ measure compose :: (Arrow b c) -> (Arrow a b) -> (Arrow a c) @-}

-- | All the followin will be autocatically generated by the definition of append
-- |  and a liquid annotation
-- |
-- |  axiomatize append
-- |

{-@ measure map :: (Arrow a b) -> L a -> L b @-}
{-@ assume map :: f:(Arrow a b) -> xs:L a -> {v:L b | v == map f xs } @-}


{-@ assume axiom_map_nil :: f:(Arrow a b) -> {v:Proof | map f N == N} @-}
axiom_map_nil :: (Arrow a b) -> Proof
axiom_map_nil f = Proof

{-@ assume axiom_map_cons :: f:(Arrow a a) -> x:a -> xs: L a
          -> {v:Proof | map f (C x xs) == C (runFun f x) (map f xs) } @-}
axiom_map_cons :: (Arrow a a) -> a -> L a -> Proof
axiom_map_cons f x xs = Proof


-- | Proof library:

data Proof = Proof


{-@ toProof :: l:a -> r:{a|l = r} -> {v:Proof | l = r } @-}
toProof :: a -> a -> Proof
toProof x y = Proof


{-@ (===) :: l:a -> r:a -> {v:Proof | l = r} -> {v:a | v = l } @-}
(===) :: a -> a -> Proof -> a
(===) x y _ = y
{-@ type Equal X Y = {v:Proof | X == Y} @-}


{-@ bound chain @-}
chain :: (Proof -> Bool) -> (Proof -> Bool) -> (Proof -> Bool) -> Proof -> Bool
chain p q r v = p v ==> q v ==> r v

{-@  assume by :: forall <p :: Proof -> Prop, q :: Proof -> Prop, r :: Proof -> Prop>.
                 (Chain p q r) => Proof<p> -> Proof<q> -> Proof<r>
@-}
by :: Proof -> Proof -> Proof
by p r = r -- todo: prove this!

{-@ refl :: x:a -> Equal x x @-}
refl :: a -> Proof
refl x = Proof



-- | Proof: fusion

{-@ prop_fusion :: f:(Arrow a a) -> g:(Arrow a a) -> xs:L a
                -> {v:Proof | map f (map g xs) ==  map (compose f g) xs }  @-}
prop_fusion     :: Eq a => (Arrow a a) -> (Arrow a a) -> L a -> Proof
prop_fusion f g N =
  refl e1 `by` pr1 `by` pr2 `by` pr3
  where
    e1  = map f (map g N)
    pr1 = axiom_map_nil g
    e2  = map f N
    pr2 = axiom_map_nil f
    e3  = N
    fg  = compose f g
    pr3 = axiom_map_nil (compose f g)
    e4  = map fg N

prop_fusion f g (C x xs) =
{-
  toProof e1 $ (((((
   e1 === e2) pr1
      === e3) pr2
      === e4) pr3
      === e5) pr4
      === e5) pr5
-}
    refl e1 `by` pr1 `by` pr2 `by` pr3 `by` pr4 -- `by` pr5
  where
    e1 = map f (map g (C x xs))
    pr1 = axiom_map_cons g x xs
    e2 = map f (C (runFun g x) (map g xs))
    pr2 = axiom_map_cons f (runFun g x) (map g xs)
    e3 = C (runFun f (runFun g x)) (map f (map g xs))
    pr3 = prop_fusion f g xs
    e4 = C (runFun f (runFun g x)) (map (compose f g) xs)
    pr4 = axiom_compose f g x
    e5 = C (runFun (compose f g) x) (map (compose f g) xs)
    pr5 = axiom_map_cons (compose f g) x xs
    e6 = map (compose f g) (C x xs)
